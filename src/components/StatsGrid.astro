---
// src/components/StatsGrid.astro
export interface Props {
    stats: Array<{
        number: string;
        label: string;
    }>;
    className?: string;
}

const { stats, className = '' } = Astro.props;
---

<div class={`stats-grid ${className}`}>
    {stats.map((stat, index) => (
        <div class="stat-item animate-on-scroll" style={`animation-delay: ${index * 0.1}s`}>
            <h3>{stat.number}</h3>
            <p>{stat.label}</p>
        </div>
    ))}
</div>



<script>
    // Optional: Add counting animation effect
    document.addEventListener('DOMContentLoaded', () => {
        const statItems = document.querySelectorAll('.stat-item h3');
        
        const animateValue = (element: HTMLElement, start: number, end: number, duration: number) => {
            let startTimestamp: number | null = null;
            const step = (timestamp: number) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                const current = Math.floor(progress * (end - start) + start);
                
                // Handle different number formats
                const originalText = element.textContent || '';
                if (originalText.includes('+')) {
                    element.textContent = current + '+';
                } else if (originalText.includes('%')) {
                    element.textContent = current + '%';
                } else if (originalText.includes('K')) {
                    element.textContent = current + 'K+';
                } else {
                    element.textContent = current.toString();
                }
                
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                }
            };
            window.requestAnimationFrame(step);
        };

        // Set up intersection observer for counting animation
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const element = entry.target as HTMLElement;
                    const text = element.textContent || '';
                    const number = parseInt(text.replace(/[^\d]/g, ''));
                    
                    if (!isNaN(number) && number > 0) {
                        element.textContent = '0';
                        setTimeout(() => {
                            animateValue(element, 0, number, 2000);
                        }, 300);
                    }
                    observer.unobserve(element);
                }
            });
        }, { threshold: 0.5 });

        statItems.forEach(item => {
            observer.observe(item);
        });
    });
</script>